from fastapi import FastAPI, File, UploadFile, HTTPException, BackgroundTasks
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse, Response, FileResponse, StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import os
import json
import zipfile
import shutil
import asyncio
from pathlib import Path
import psutil
from PIL import Image, ImageOps
import uuid
import time
import tempfile
import re
from io import BytesIO

from cluster import build_plan, distribute_to_folders, process_group_folder, IMG_EXTS

app = FastAPI(title="–ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –ª–∏—Ü", description="API –¥–ª—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ –ª–∏—Ü –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ –≥—Ä—É–ø–ø–∞–º")

# CORS middleware –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ —Å—Ç–æ–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Redis/Database)
app_state = {
    "queue": [],
    "current_tasks": {},
    "task_history": []
}

# –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö
class FolderInfo(BaseModel):
    path: str
    name: str
    is_directory: bool
    size: Optional[int] = None
    image_count: Optional[int] = None

class QueueItem(BaseModel):
    path: str

class TaskProgress(BaseModel):
    task_id: str
    status: str  # "pending", "running", "completed", "error"
    progress: int
    message: str
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class ProcessingResult(BaseModel):
    moved: int
    copied: int
    clusters_count: int
    unreadable_count: int
    no_faces_count: int
    unreadable_files: List[str]
    no_faces_files: List[str]

class MoveItem(BaseModel):
    src: str
    dest: str

# –£—Ç–∏–ª–∏—Ç—ã
def cleanup_old_tasks():
    """–£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ (—Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω—É—Ç)"""
    current_time = time.time()
    tasks_to_remove = []
    
    for task_id, task in app_state["current_tasks"].items():
        if task["status"] in ["completed", "error"]:
            # –£–¥–∞–ª—è–µ–º –∑–∞–¥–∞—á–∏ —Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω—É—Ç
            if current_time - task["created_at"] > 300:  # 5 –º–∏–Ω—É—Ç
                tasks_to_remove.append(task_id)
    
    for task_id in tasks_to_remove:
        del app_state["current_tasks"][task_id]

def get_logical_drives():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –¥–∏—Å–∫–æ–≤"""
    return [Path(p.mountpoint) for p in psutil.disk_partitions(all=False) if Path(p.mountpoint).exists()]

def get_special_dirs():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏"""
    home = Path.home()
    return {
        "üíº –†–∞–±–æ—á–∏–π —Å—Ç–æ–ª": home / "Desktop",
        "üìÑ –î–æ–∫—É–º–µ–Ω—Ç—ã": home / "Documents", 
        "üì• –ó–∞–≥—Ä—É–∑–∫–∏": home / "Downloads",
        "üñº –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è": home / "Pictures",
    }

def count_images_in_dir(path: Path) -> int:
    """–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏"""
    try:
        return len([f for f in path.iterdir() if f.is_file() and f.suffix.lower() in IMG_EXTS])
    except:
        return 0

def get_folder_contents(path: Path) -> List[FolderInfo]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏"""
    try:
        contents = []
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫—É—é –ø–∞–ø–∫—É –µ—Å–ª–∏ –Ω–µ –∫–æ—Ä–µ–Ω—å
        if path.parent != path:
            contents.append(FolderInfo(
                path=str(path.parent),
                name="‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
                is_directory=True
            ))
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–ø–∞–ø–∫–∏
        for item in sorted(path.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower())):
            if item.is_dir():
                image_count = count_images_in_dir(item)
                contents.append(FolderInfo(
                    path=str(item),
                    name=f"üìÇ {item.name}",
                    is_directory=True,
                    image_count=image_count
                ))
            elif item.suffix.lower() in IMG_EXTS:
                try:
                    size = item.stat().st_size
                    contents.append(FolderInfo(
                        path=str(item),
                        name=f"üñº {item.name}",
                        is_directory=False,
                        size=size
                    ))
                except:
                    pass
        
        return contents
    except PermissionError:
        raise HTTPException(status_code=403, detail=f"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–ø–∫–µ: {path}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –ø–∞–ø–∫–∏: {str(e)}")

async def process_folder_task(task_id: str, folder_path: str):
    """–§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–∞–ø–∫–∏"""
    try:
        app_state["current_tasks"][task_id]["status"] = "running"
        app_state["current_tasks"][task_id]["message"] = "–ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É..."
        app_state["current_tasks"][task_id]["progress"] = 5
        
        # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
        await asyncio.sleep(2)
        app_state["current_tasks"][task_id]["progress"] = 10
        app_state["current_tasks"][task_id]["message"] = "–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è..."
        
        await asyncio.sleep(2)
        app_state["current_tasks"][task_id]["progress"] = 25
        app_state["current_tasks"][task_id]["message"] = "–ò–∑–≤–ª–µ–∫–∞–µ–º –ª–∏—Ü–∞..."
        
        await asyncio.sleep(2)
        app_state["current_tasks"][task_id]["progress"] = 50
        app_state["current_tasks"][task_id]["message"] = "–ö–ª–∞—Å—Ç–µ—Ä–∏–∑—É–µ–º –ª–∏—Ü–∞..."
        
        path = Path(folder_path)
        if not path.exists():
            raise Exception("–ü—É—Ç—å –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–∞–ø–∫–∞ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∏—Å–∫–ª—é—á–∞–µ–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è
        excluded_names = ["–æ–±—â–∏–µ", "–æ–±—â–∞—è", "common", "shared", "–≤—Å–µ", "all", "mixed", "—Å–º–µ—à–∞–Ω–Ω—ã–µ"]
        folder_name_lower = str(path).lower()
        for excluded_name in excluded_names:
            if excluded_name in folder_name_lower:
                raise Exception(f"–ü–∞–ø–∫–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º '{excluded_name}' –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è")
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ–±—Ä–∞–±–æ—Ç–∫–∏ - –≥—Ä—É–ø–ø–æ–≤–∞—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –ø–æ–¥–ø–∞–ø–∫–∏ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
        subdirs_with_images = []
        for p in path.iterdir():
            if p.is_dir() and not any(excluded_name in str(p).lower() for excluded_name in excluded_names):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ø–æ–¥–ø–∞–ø–∫–µ
                has_images = any(f.suffix.lower() in IMG_EXTS for f in p.rglob("*") if f.is_file())
                if has_images:
                    subdirs_with_images.append(p)
        
        if len(subdirs_with_images) > 1:
            # –ì—Ä—É–ø–ø–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
            def group_progress_callback(progress_text: str, percent: int = None):
                if task_id in app_state["current_tasks"]:
                    app_state["current_tasks"][task_id]["message"] = progress_text
                    if percent is not None:
                        app_state["current_tasks"][task_id]["progress"] = percent
                    else:
                        try:
                            if "%" in progress_text:
                                match = re.search(r'(\d+)%', progress_text)
                                if match:
                                    app_state["current_tasks"][task_id]["progress"] = int(match.group(1))
                        except:
                            pass
            
            app_state["current_tasks"][task_id]["message"] = "–ì—Ä—É–ø–ø–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–∞–ø–æ–∫..."
            app_state["current_tasks"][task_id]["progress"] = 10
            
            process_group_folder(path, progress_callback=group_progress_callback)
            result = ProcessingResult(
                moved=0, copied=0, clusters_count=0,
                unreadable_count=0, no_faces_count=0,
                unreadable_files=[], no_faces_files=[]
            )
        else:
            # –û–±—ã—á–Ω–∞—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è
            def progress_callback(progress_text: str, percent: int = None):
                if task_id in app_state["current_tasks"]:
                    app_state["current_tasks"][task_id]["message"] = progress_text
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç –∏–ª–∏ –ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –∏–∑ —Ç–µ–∫—Å—Ç–∞
                    if percent is not None:
                        app_state["current_tasks"][task_id]["progress"] = percent
                    else:
                        try:
                            if "%" in progress_text:
                                # –ò—â–µ–º —á–∏—Å–ª–æ –ø–µ—Ä–µ–¥ –∑–Ω–∞–∫–æ–º %
                                match = re.search(r'(\d+)%', progress_text)
                                if match:
                                    app_state["current_tasks"][task_id]["progress"] = int(match.group(1))
                        except:
                            pass
            
            app_state["current_tasks"][task_id]["message"] = "–ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –ª–∏—Ü..."
            await asyncio.sleep(2)
            app_state["current_tasks"][task_id]["progress"] = 75
            plan = build_plan(path, progress=progress_callback)
            
            app_state["current_tasks"][task_id]["message"] = "–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –ø–∞–ø–∫–∞–º..."
            app_state["current_tasks"][task_id]["progress"] = 90
            await asyncio.sleep(1)
            
            moved, copied, next_cluster_id = distribute_to_folders(plan, path, progress_callback=progress_callback)
            
            result = ProcessingResult(
                moved=moved,
                copied=copied, 
                clusters_count=len(plan.get("clusters", {})),
                unreadable_count=len(plan.get("unreadable", [])),
                no_faces_count=len(plan.get("no_faces", [])),
                unreadable_files=plan.get("unreadable", [])[:30],
                no_faces_files=plan.get("no_faces", [])[:30]
            )
        
        app_state["current_tasks"][task_id]["status"] = "completed"
        app_state["current_tasks"][task_id]["progress"] = 100
        app_state["current_tasks"][task_id]["message"] = "–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞"
        app_state["current_tasks"][task_id]["result"] = result.model_dump()
        
    except Exception as e:
        app_state["current_tasks"][task_id]["status"] = "error"
        app_state["current_tasks"][task_id]["error"] = str(e)
        app_state["current_tasks"][task_id]["message"] = f"–û—à–∏–±–∫–∞: {str(e)}"

# API endpoints
@app.get("/", response_class=HTMLResponse)
async def get_index():
    """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞"""
    with open("static/index.html", "r", encoding="utf-8") as f:
        return HTMLResponse(f.read())

@app.get("/api/drives")
async def get_drives():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–∏—Å–∫–æ–≤ –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –ø–∞–ø–æ–∫"""
    drives = []
    
    # –õ–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∏—Å–∫–∏
    for drive in get_logical_drives():
        drives.append({
            "path": str(drive),
            "name": f"üìç {drive}",
            "type": "drive"
        })
    
    # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ø–∞–ø–∫–∏
    for name, path in get_special_dirs().items():
        if path.exists():
            drives.append({
                "path": str(path),
                "name": name,
                "type": "special"
            })
    
    return drives

@app.get("/api/folder")
async def get_folder_info(path: str):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏"""
    folder_path = Path(path)
    if not folder_path.exists():
        raise HTTPException(status_code=404, detail="–ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    
    contents = get_folder_contents(folder_path)
    image_count = count_images_in_dir(folder_path)
    
    return {
        "path": str(folder_path),
        "contents": contents,
        "image_count": image_count
    }

@app.post("/api/upload")
async def upload_files(
    path: str,
    files: List[UploadFile] = File(...)
):
    """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã –≤ —É–∫–∞–∑–∞–Ω–Ω—É—é –ø–∞–ø–∫—É"""
    target_dir = Path(path)
    if not target_dir.exists():
        raise HTTPException(status_code=404, detail="–¶–µ–ª–µ–≤–∞—è –ø–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    
    results = []
    
    for file in files:
        try:
            if file.filename.endswith(".zip"):
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ ZIP –∞—Ä—Ö–∏–≤–∞
                temp_zip = target_dir / f"temp_{uuid.uuid4().hex}.zip"
                with open(temp_zip, "wb") as f:
                    content = await file.read()
                    f.write(content)
                
                with zipfile.ZipFile(temp_zip) as archive:
                    archive.extractall(target_dir)
                
                temp_zip.unlink()
                results.append({"filename": file.filename, "status": "extracted"})
            else:
                # –û–±—ã—á–Ω—ã–π —Ñ–∞–π–ª
                file_path = target_dir / file.filename
                with open(file_path, "wb") as f:
                    content = await file.read()
                    f.write(content)
                results.append({"filename": file.filename, "status": "uploaded"})
                
        except Exception as e:
            results.append({"filename": file.filename, "status": "error", "error": str(e)})
    
    return {"results": results}

@app.get("/api/queue")
async def get_queue():
    """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ—á–µ—Ä–µ–¥—å –æ–±—Ä–∞–±–æ—Ç–∫–∏"""
    return {"queue": app_state["queue"]}

@app.post("/api/queue/add")
async def add_to_queue(item: QueueItem):
    """–î–æ–±–∞–≤–∏—Ç—å –ø–∞–ø–∫—É –≤ –æ—á–µ—Ä–µ–¥—å"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–∞–ø–∫–∞ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∏—Å–∫–ª—é—á–∞–µ–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è
    excluded_names = ["–æ–±—â–∏–µ", "–æ–±—â–∞—è", "common", "shared", "–≤—Å–µ", "all", "mixed", "—Å–º–µ—à–∞–Ω–Ω—ã–µ"]
    folder_name_lower = str(item.path).lower()
    for excluded_name in excluded_names:
        if excluded_name in folder_name_lower:
            raise HTTPException(status_code=400, detail=f"–ü–∞–ø–∫–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º '{excluded_name}' –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è")
    
    if item.path not in app_state["queue"]:
        app_state["queue"].append(item.path)
        return {"message": f"–ü–∞–ø–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å: {item.path}"}
    else:
        return {"message": "–ü–∞–ø–∫–∞ —É–∂–µ –≤ –æ—á–µ—Ä–µ–¥–∏"}

@app.delete("/api/queue")
async def clear_queue():
    """–û—á–∏—Å—Ç–∏—Ç—å –æ—á–µ—Ä–µ–¥—å"""
    app_state["queue"].clear()
    return {"message": "–û—á–µ—Ä–µ–¥—å –æ—á–∏—â–µ–Ω–∞"}

@app.post("/api/process")
async def process_queue(background_tasks: BackgroundTasks):
    """–ó–∞–ø—É—Å—Ç–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—á–µ—Ä–µ–¥–∏"""
    if not app_state["queue"]:
        raise HTTPException(status_code=400, detail="–û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞")
    
    task_ids = []
    
    for folder_path in app_state["queue"]:
        task_id = str(uuid.uuid4())
        app_state["current_tasks"][task_id] = {
            "task_id": task_id,
            "status": "pending",
            "progress": 0,
            "message": "–í –æ—á–µ—Ä–µ–¥–∏...",
            "folder_path": folder_path,
            "created_at": time.time()
        }
        
        background_tasks.add_task(process_folder_task, task_id, folder_path)
        task_ids.append(task_id)
    
    app_state["queue"].clear()
    return {"message": "–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞", "task_ids": task_ids}

@app.get("/api/tasks")
async def get_tasks():
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤—Å–µ—Ö –∑–∞–¥–∞—á"""
    # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–¥–∞—á–∏
    cleanup_old_tasks()
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏ (–≤–∫–ª—é—á–∞—è –Ω–µ–¥–∞–≤–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ)
    return {"tasks": list(app_state["current_tasks"].values())}

@app.get("/api/tasks/{task_id}")
async def get_task(task_id: str):
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∑–∞–¥–∞—á–∏"""
    if task_id not in app_state["current_tasks"]:
        raise HTTPException(status_code=404, detail="–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    
    return app_state["current_tasks"][task_id]

@app.post("/api/tasks/clear")
async def clear_completed_tasks():
    """–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏"""
    tasks_to_remove = []
    
    for task_id, task in app_state["current_tasks"].items():
        if task["status"] in ["completed", "error"]:
            tasks_to_remove.append(task_id)
    
    for task_id in tasks_to_remove:
        del app_state["current_tasks"][task_id]
    
    return {"message": f"–û—á–∏—â–µ–Ω–æ {len(tasks_to_remove)} –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á"}

@app.get("/api/image/preview")
async def get_image_preview(path: str, size: int = 150):
    """–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–≤—å—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    img_path = Path(path)
    if not img_path.exists() or img_path.suffix.lower() not in IMG_EXTS:
        raise HTTPException(status_code=404, detail="–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    try:
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–≤—å—é –≤ –ø–∞–º—è—Ç–∏
        with Image.open(img_path) as img:
            img = img.convert("RGB")
            img = ImageOps.fit(img, (size, size), Image.Resampling.LANCZOS)
            buf = BytesIO()
            img.save(buf, format="JPEG", quality=85)
            buf.seek(0)
            from fastapi.responses import StreamingResponse
            return StreamingResponse(buf, media_type="image/jpeg")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–µ–≤—å—é: {str(e)}")

@app.get("/api/zip")
async def zip_folder(path: str):
    """–°–æ–∑–¥–∞–µ—Ç ZIP –∞—Ä—Ö–∏–≤–∞—Ü–∏—é —É–∫–∞–∑–∞–Ω–Ω–æ–π –ø–∞–ø–∫–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–∞–π–ª"""
    folder = Path(path)
    if not folder.exists() or not folder.is_dir():
        raise HTTPException(status_code=404, detail="–ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π zip-—Ñ–∞–π–ª
    tmp_dir = tempfile.gettempdir()
    zip_name = f"{uuid.uuid4()}.zip"
    zip_path = Path(tmp_dir) / zip_name
    # –î–µ–ª–∞–µ—Ç –∞—Ä—Ö–∏–≤
    shutil.make_archive(str(zip_path.with_suffix('')), 'zip', root_dir=folder)
    # –û—Ç–¥–∞–µ—Ç —Ñ–∞–π–ª –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
    return FileResponse(str(zip_path), media_type="application/zip", filename=f"{folder.name}.zip")

# Add SSE endpoint for streaming tasks
@app.get("/api/stream/tasks")
async def stream_tasks():
    """Stream all task updates via Server-Sent Events"""
    async def event_generator():
        while True:
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–¥–∞—á–∏
            cleanup_old_tasks()
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏ (pending, running)
            active_tasks = [
                task for task in app_state["current_tasks"].values() 
                if task["status"] in ["pending", "running"]
            ]
            
            data = {"tasks": active_tasks}
            yield f"data: {json.dumps(data)}\n\n"
            await asyncio.sleep(1)
    return StreamingResponse(event_generator(), media_type="text/event-stream")

# –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã
app.mount("/static", StaticFiles(directory="static"), name="static")

@app.post("/api/move")
async def move_item(item: MoveItem):
    """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —Ñ–∞–π–ª –∏–ª–∏ –ø–∞–ø–∫—É"""
    src_path = Path(item.src)
    dest_path = Path(item.dest)
    if not src_path.exists():
        raise HTTPException(status_code=404, detail="–ò—Å—Ç–æ—á–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω")
    if not dest_path.exists():
        raise HTTPException(status_code=404, detail="–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    target = dest_path / src_path.name
    try:
        shutil.move(str(src_path), str(target))
        return {"message": "–£—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–æ", "src": str(src_path), "dest": str(target)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è: {e}")

@app.get("/favicon.ico")
async def favicon():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ—Å—Ç–æ–π favicon —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å 404 –æ—à–∏–±–æ–∫"""
    return Response(content="", media_type="image/x-icon")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
